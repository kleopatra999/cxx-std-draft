<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>A visitor&rsquo;s guide to allocators</title>
    <link type="text/css" rel="stylesheet" href="allocator_guide.css">
  </head>

  <!--
        TODO
        ====

        * Explain offset pointers better and whether/how they need (stateful?) allocators.

        * Make the demonstration of scoped_allocator_adaptor clearer and more general.


        Revision history
        ================

        2014-06-22: First draft [tkoeppe]
        2014-06-23: Revisions, incorporating feedback from JW [tkoeppe]
        2014-07-16: Add links to examples, and examples.

  -->

  <body>
    <div class="docinfo">
      <!-- p>ISO/IEC JTC1 SC22 WG21 N????</p -->
      <p>Date: 2014-07-16</p>
      <address>Thomas K&ouml;ppe &lt;<a href="mailto:tkoeppe@google.com">tkoeppe@google.com</a>&gt;</address>
    </div>

    <h1><span style="font-style: italic;">&ldquo;Under Construction&rdquo;</span><br>
    A visitor&rsquo;s guide to C++ allocators</h1>

    <p style="text-align: center; margin-top: 4em; font-style: italic;">Contributors and collaborators welcome!</p>

    <!-- fgrep -e "<h2 id=" allocator_user_guide.html | sed -e 's/.*id="\(.*\)">\(.*\)<\/h2>/<li><a href="#\1">\2<\/a><\/li>/g' -->
    <h2>Contents</h2>
    <ol class="tight">
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#background">Background</a></li>
      <li><a href="#alloc">Allocators</a></li>
      <li><a href="#pointers">Pointers</a></li>
      <li><a href="#alloconst">From allocation to construction</a></li>
      <li><a href="#reqs">Requirements for allocators and pointers</a></li>
      <li><a href="#mut">Allocator identity</a></li>
      <li><a href="#contreqs">Standard library container requirements</a></li>
      <li><a href="#propagation">Propagating allocators</a></li>
      <li><a href="#examples">Examples</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ol>

    <h2 id="introduction">Introduction</h2>

    <p>Allocators are perphaps one of the most pervasive, yet least loved parts of the C++ standard library.
      This guide attempts to explain what allocators are and how library authors are supposed to use them.
      On this brief journey through one of the wilder realms of C++ we will meet allocator traits, pointer
      traits, fancy pointers and cast operations that will shake even the strongest minds.</p>

    <h2 id="background">Background</h2>

    <p>C++ classes often manage dynamic resources as part of their implementation. Typical examples of such classes
      are dynamic containers, strings, function wrappers, file handles, mutexes, etc. There is one distinguished
      resource which is needed to create new C++ objects: <em>memory</em>. Given appropriate memory (i.e. of the right size
      and alignment) at some address <code>p</code>, we can bring to life a new C++ object of type <code>T</code> by
      saying <code>::new (p) T</code>. This is the fundamental idea underpinning all dynamic containers.</p>
    <p>However, the mechamism by which suitable memory is obtained is system-specific and essentially opaque to the user.
      C++ offers a default mechanism, <code>::operator new(sizeof(T))</code>, but there is little to no control over
      what this does. Since the logic of a dynamic container does not depend on the specifics of how memory is obtained,
      general wisdom dictates that the design of container classes should be decoupled from the memory allocation policy.
      Enter allocators.</p>

    <p>For the remainder of this guide, it will be useful to have a few concrete and representative examples in mind.
      We pick two, which are ubiquitous and well-known. Note that the dynamic resource allocation and deallocation is
      entirely opaque to the user, who only ever observes the contained element values. The container <em>owns</em> the
      elements and is responsible for their storage and lifetime.</p>
    <ul>
      <li>A contiguous-range, dynamic array that can grow and shrink (e.g. <code>std::vector&lt;T&gt;</code>). Dynamic
        memory needs to be obtained once for the entire contiguous storage of elements, and elements need to be constructed
        one by one in that memory. At any given time, there may be more memory allocated than what is occupied by element
        objects.</li>
      <li>A linked list (e.g. <code>std::list&lt;T&gt;</code>). For each list element, a <em>list node</em> needs to be
        allocated dynamically, which in turn contains the element value as well as the link pointers.</li>
    </ul>

    <h2 id="alloc">Allocators</h2>

    <p>The C++ standard library defines the notion of an <em>allocator</em>, which is an object used to parametrize
      memory allocation and object construction. The point that an allocator has <em>two separate responsibilities</em>
      is worth repeating: an allocator knows how to obtain memory, and it knows how to construct objects.</p>
    <p>To understand why allocators are useful, let us step back into a world without allocators. Creating a dynamic object
      can be broken down into separate steps, which are typically hidden behind the convenience expressions <code>new</code>
      and <code>delete</code>:</p>
    <div style="width: 48%; float: right;">
      <strong>Broken down operations</strong>
      <div class="code strictpre">void * addr = ::operator new(sizeof(T));   // allocation
T * p = ::new (addr) T(1, 'x', true);      // construction

p-&gt;~T();                                   // destruction
// (no placement-delete in normal execution flow)

::operator delete(addr);                   // deallocation</div>
    </div>
    <div style="width: 48%;">
      <strong>Convenient use</strong>
      <div class="code strictpre">T * p = ::new T(1, 'x', true);  // allocation and construction


::delete p;                     // destruction and deallocation



</div>
    </div>

    <p>The broken-down operations show the mental model that allocators are intended to parametrize. To achieve this,
      an allocator defines four fundamental operations: <code>allocate</code>, <code>deallocate</code>, <code>construct</code>,
      and <code>destroy</code>, which generalize, respectively, to the allocation function (<code>::operator new</code>), the
      deallocation function (<code>::operator delete</code>), placement-<code>new</code>, and the explicit destructor call.</p>

    <p>To go into further detail, we need to establish some terminology. The standard reference is section [allocator.requirements].</p>

    <p>The standard header <code>&lt;memory&gt;</code> defines
      a trait class template <code>allocator_traits</code>, which provides a uniform interface to allocators. The allocator traits
      reflect certain members of the actual allocator type, but they also provide defaults, so that a custom allocator only needs to
      provide a minimal set of information that differs from the defaults. (The traits template may be specialized for user-defined
      types, and different defaults may be provided in a specialization.)</p>
    <p>Suppose <code>a</code> is an allocator of type <code>Alloc</code>. Let us write <code>AllocTraits = std::allocator_traits&lt;Alloc&gt;</code>.
      We say that &ldquo;<code>a</code> is an allocator for <code>T</code>&rdquo;, where <code>T = AllocTraits::value_type</code>. This
      means that <code>a</code> knows how to obtain and release memory to store objects of type <code>T</code>. To do so, we call
      <code>AllocTraits::allocate(a, n)</code>, and we obtain storage for <code>n</code> objects of type <code>T</code>.
    </p><p>So far so good. However, we can also use <code>a</code> to construct objects, either explicitly or via a default mechanism.
      But not just objects of type <code>T</code>,
      but <em>any</em> type of object! This is very much intentional. Recall our example of a linked list. We would like
      to be able to allocate memory for an entire list node, but we only need to construct objects of list element type. So it is
      convenient if a single allocator knows how to construct objects of different types.</p>
    <p>Here is how this works. For <em>any</em> pointer <code>C * c</code>, and any list of arguments <code>args...</code>,
      we can say <code>AllocTraits::construct(a, c, args...)</code>. This either invokes <code>::new (static_cast&lt;void *&gt;(c))
      C(std::forward&lt;Args&gt;(args)...)</code>, or, if <code>Alloc</code> defines a suitable member function, <code>a.construct(c,
      std::forward&lt;Args&gt;(args)...)</code>. In either case, the result is than an object of type <code>C</code> is constructed
      from the arguments at location <code>c</code>, and that afterwards <code>*c</code> is that object. In other words, a new object
      is constructed in a given piece of raw memory. Similarly, we can call <code>AllocTraits::destroy(a, c)</code> to destroy the
      object. This defaults to <code>c-&gt;~C()</code>, or calls <code>a.destroy(c)</code> if that expression is well-formed.</p>

    <h2 id="pointers">Pointers</h2>

    <p>So far we have dived right into object construction, but skirted the more fundamental question of how to allocate memory. Our
      allocator <code>a</code> for <code>T</code> can only allocate memory for a contiguous sequence of objects of type <code>T</code>.
      To allocate memory for <code>n</code> such objects, we say:</p>
    <div class="code">AllocTraits::pointer p = AllocTraits::allocate(a, n);</div>
    <p>The allocator communicates memory in terms of customizable type <code>AllocTraits::pointer</code>. This defaults to the
      unsurprising <code>T *</code>, but it <em>may be any user-defined type</em>. When <code>AllocTraits::pointer</code> is not
      the same as <code>T *</code>, we say that the allocator uses a <em>fancy pointer</em>. The allocator also defines a corresponding
      &ldquo;void pointer&rdquo; via <code>AllocTraits::void_pointer</code>. Pointers and void pointers are convertible to one another.</p>
    <p>(The typical example of a fancy pointer is an &ldquo;offset pointer&rdquo; into shared memory that allows separate processes
      to access the same object in shared memory; the offset pointer stores only an offset, relative to the pointer object&rsquo;s own
      address. This example demonstrates
      the complexity of the problem: The vector&rsquo;s own memory must be in shared memory; each member list
      must allocate from the same shared memory; each string in the list must allocate from the shared memory, and all references are
      expressed in terms of relative offsets. However, each process must be able to obtain a proper, &ldquo;normal&rdquo; address for
      each object, even if the object is stored in shared memory, by virtue of the dereference operation.)

    </p><p>Now that we have convinced ourselves that pointers are not an altogether trivial matter, it is time to introduce the final
      level of abstraction that the standard library has to offer: pointer traits. This is a class template, called <code>std::pointer_traits</code>,
      also defined in <code>&lt;memory&gt;</code>, and among other things it allows us to obtain pointers to objects (including fancy pointers).
      Let us write <code>AllocPtrTraits = std::pointer_traits&lt;AllocTraits::pointer&gt;</code>. The pointer traits define an <em>element
      type</em> via <code>AllocPtrTraits::element_type</code>, which is either just the allocator&rsquo;s value type <code>T</code> if
      <code>AllocTraits::pointer == T *</code>, or otherwise it is reflected out of the fancy pointer type.
      The important operation provided by pointer traits is obtaining a pointer to an element: <code>AllocPtrTraits::pointer_to(r)</code>
      produces a pointer, either by computing <code>std::addressof(r)</code> if <code>AllocTraits::pointer == T *</code>, or otherwise
      by a mechanism specified by the fancy pointer class. See below for details. Finally, it is a requirement that <code>AllocTraits::pointer</code>
      must be dereferencable (producing a value of type <code>AllocTraits::value_type</code>) by providing <code>operator*</code> and <code>operator-&gt;</code>.</p>

    <h3>Fancy pointer summary</h3>

    <p>We write <code>T = AllocTraits::value_type</code> for brevity.</p>
    <ul>
      <li>If <code>AllocTraits::pointer</code> is a user-defined class type (and not <code>T *</code>), we say that <code>Alloc</code>
        uses fancy pointers.</li>
      <li>For a glvalue <code>r</code> of type <code>T</code>, we have a &ldquo;fancy address-of operator&rdquo;:
        <code>AllocTraits::pointer ptr = AllocPtrTraits::pointer_to(r);</code></li>
      <li>For a fancy pointer <code>AllocTraits::pointer ptr</code>, we have a &ldquo;fancy dereference operator&rdquo;: <code>T &amp; r = *ptr;</code></li>
      <li>We can obtain the &ldquo;true address&rdquo;, i.e. the address of the object obtained by dereferencing a fancy pointer, by the following operation:<br><br>
        <div class="code">template &lt;typename FancyPtr&gt;
          auto trueaddress(FancyPtr ptr)
          {
          &nbsp;&nbsp;return std::addressof(*ptr);
          }</div></li>
    </ul>

    <p>Putting it all together, we arrive at a self-consistency identity for pointers:</p>
    <div class="code">ptr == std::pointer_traits&lt;AllocTraits::pointer&gt;::pointer_to(*trueaddress(ptr))</div>

    <h2 id="alloconst">From allocation to construction</h2>

    <p>Suppose now we have an allocator <code>Alloc a;</code> for a type <code>T</code> and we would like to
      allocate memory and construct the object from some given arguments. We continue writing <code>AllocTraits</code>
      for <code>std::allocator_traits&lt;Alloc&gt;</code>. We need the following sequence of operations.</p>
    <div class="code strictpre">Alloc a;                                                    // given T-allocator

AllocTraits::pointer ptr = AllocTraits::allocate(a, 1);     // space for one element

AllocTraits::construct(a, trueaddress(ptr), x, y, z);       // constructs a T(x, y, z)

AllocTraits::destroy(a, trueaddress(ptr));                  // ~T()

AllocTraits::deallocate(a, ptr, 1);                         // deallocate element space</div>

    <h2 id="reqs">Requirements for allocators and pointers</h2>

    <p>The full set of requirements is spread out in the C++ standard across the sections [allocator.requirements],
      [allocator.traits] and [pointer.traits]. We collect a few of the essential requirements here. We continue
      writing <code>Alloc</code> for some, generic allocator type, and <code>AllocTraits</code> and
      <code>AllocPtrTraits</code> for its related allocator traits and pointer traits type.</p>
    <ul>
      <li><code>Alloc</code> must define a member type <code>value_type</code>. <code>Alloc</code> is an allocator
        type &ldquo;for that value&rdquo;.</li>
      <li><code>Alloc</code> may define a member type <code>pointer</code>, in which case <code>AllocTraits::pointer</code>
        and <code>AllocPtrTraits::pointer</code> are that same type; otherwise they are <code>Alloc::value_type *</code>.</li>
      <li><code>Alloc</code> may define a member template <code>rebind</code> for rebinding. This may be omitted if <code>Alloc</code>
        is itself a template class <code>A&lt;T, Args...&gt;</code> where the value type is the first template argument, in which case
        <code>AllocTraits::rebind_alloc&lt;U&gt;</code> defaults to <code>A&lt;U, Args...&gt;</code>.
      </li><li>If <code>Alloc::pointer</code> is defined and a user-defined class type (as opposed to <code>Alloc::value_type *</code>), then
        we say that <code>Alloc</code> has a fancy pointer. In that case:
        <ul>
          <li><code>Alloc::pointer</code> should have a member type <code>element_type</code> (though it need
            not have such a member type if it is a template class <code>P&lt;V, Args...&gt;</code>, in which case
            <code>AllocPtrTraits::element_type</code> is <code>V</code>).</li>
          <li><code>Alloc::pointer</code> must have a static member function <code>pointer_to</code> taking a single
            argument of type <code>element_type</code> and returning a fancy pointer object.</li>
        </ul>
      </li>
    </ul>

    <h2 id="mut">Allocator identity</h2>

    <p>Allocators are strange animals in the C++ bestiary. The operational identity of an allocator object is not really connected
      with the object itself, but rather, the identity is spread out over a whole family of related allocators. Given an allocator
      <code>a</code> of type <code>Alloc</code> for a type <code>T</code>, we can always obtain an allocator for a different type
      <code>U</code> like this:</p>
    <div class="code">std::allocator_traits&lt;Alloc&gt;::rebind_alloc&lt;U&gt; b(a);
    assert(a == b);</div>
    <p>We call <code>b</code> a <em>rebound copy of <code>a</code> for <code>U</code></em>.</p>
    <p>In this construction, all that matters is that we construct one allocator from another one. This allows allocators to pass
      on some internal state. (However, if the allocator is <em>empty</em> and DefaultConstructible, then there is no distinction
      between constructing a rebound
      allocator from an original allocator and just default-constructing the rebound allocator.) The upshot is that we can obtain
      allocators for any type from any one given allocator, and <em>all</em> the allocators thus obtained are compatible in the sense
      that memory that was obtained with any one allocator in the family can always be deallocated with a new allocator built from
      any one allocator in the family.</p>
    <p>In fact, it is required that for any two allocators <code>a1, a2</code> of the same type, <code>a1 == a2</code> holds whenever
      memory allocated with one can be deallocated with the other. This must be true when we have <code>Alloc a1, a2(a1);</code>, but
      it may also be true in other cases. And there is more: For any two allocators <code>Alloc a</code> and <code>AllocTraits::rebind_alloc&lt;U&gt; b</code>, the
      comparison <code>a == b</code> is defined as <code>a == AllocTraits::rebind_alloc&lt;Alloc::value_type&gt;(b)</code>.</p>
    <p>So we can say that the identity of an allocator family lies in the shared state much more than in any one object, and
      if there is no shared state (as is the case with <code>std::allocator&lt;T&gt;</code>), then <em>all</em> allocators obtained by
      rebinding one allocator are in the same, compatible family. Let us summarize:</p>
    <ul>
      <li>An allocator type <code>Alloc</code> defines a family of allocator types <code>AllocTraits::rebind_alloc&lt;U&gt;</code>
        for all types <code>U</code>.</li>
      <li>An allocator object <code>Alloc a</code> defines a compatible family of allocator objects via rebound copy,
        <code>AllocTraits::rebind_alloc&lt;U&gt;(a)</code>, and every object in that family defines the same family.</li>
    </ul>
    <p>We can apply rebound copies repeatedly to arrive at a self-consistency identity for allocators. For any <code>Alloc
      a</code> and any type <code>U</code>:</p>
    <div class="code">a == std::allocator_traits&lt;AllocTraits::rebind_alloc&lt;U&gt;&gt;::rebind_alloc&lt;Alloc::value_type&gt;(AllocTraits::rebind_alloc&lt;U&gt;(a))</div>


    <h2 id="contreqs">Standard library container requirements</h2>

    <p>The standard library container requirements (cf. [container.requirements.general]) mandate that the <code>construct</code> and
      <code>destroy</code> functions of the allocator of a container only be used to construct and destroy container elements, but
      not any internal data structures. In our linked list example, this means that in order to comply with the container requirements,
      the list nodes themselves may not be constructed with the allocator, only the actual data elements must be so constructed. This
      may be implemented by designing the list node type so that it has a trivial constructor and destructor, so that allocated memory
      may be treated directly as a list node as soon as storage for it has been obtained.</p>

    <h3>An example: the linked list</h3>

    <p>This example is worth spelling out in detail. Suppose we have elements of type <code>T</code>, list nodes of type
      <code>Node&lt;T&gt;</code>, and an allocator <code>a</code> for <code>T</code> of type <code>Alloc</code>. We have to design
      <code>Node&lt;T&gt;</code> so that it is trivially constructable and contains storage for <code>T</code>; for example:</p>
    <div class="code">template &lt;typename T&gt; struct Node {
      &nbsp;&nbsp;Node * prev;
      &nbsp;&nbsp;Node * next;
      &nbsp;&nbsp;typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type storage;
    };</div>
    <p>We need a helper function to access the storage as though it were a <code>T</code>:</p>
    <div class="code">T * storage(Node&lt;T&gt; * n) { return reinterpret_cast&lt;T *&gt;(&amp;n-&gt;storage); }</div>
    <p>Now we create a new node with a value constructed from some arguments, and then destroy it right away:</p>
    <div class="code strictpre">Alloc a;                                                                  // given T-allocator
using NodeTraits = std::allocator_traits&lt;Alloc&gt;::rebind_traits&lt;Node&lt;T&gt;&gt;;  // node allocator traits type
NodeTraits::allocator_type n_a(a);                                        // node allocator

NodeTraits::pointer ptr = NodeTraits::allocate(n_a, 1);                   // space for one node

NodeTraits::construct(n_a, storage(trueaddress(ptr)), x, y, z);           // constructs a T(x, y, z)

NodeTraits::destroy(n_a, storage(trueaddress(ptr)));                      // ~T()

NodeTraits::deallocate(n_a, ptr, 1);                                      // deallocate node space</div>

    <p>Note that <code>n_a</code> is a rebound copy for <code>Node&lt;T&gt;</code> of the original allocator <code>a</code>. Moreover,
      we use <code>n_a</code> and not <code>a</code> to construct elements, even though the elements are actually of type <code>T</code>,
      which is the value type of <code>a</code> and not of <code>n_a</code>. Allocators are designed to be able to construct arbitrary
      objects, not just objects of their own value type. Practically, this allows us to only keep a copy of the node allocator around,
      and never store a copy of the original allocator.</p>

    <h3>Another example: vector</h3>

    <p>Let us also study how a contiguous storage container like <code>std::vector</code> should use
      allocators. The situation is rather simpler than for the linked list. A vector of <code>T</code>
      only needs one allocator <code>a</code> for <code>T</code>, which we continue to call <code>Alloc</code>.
      To obtain storage of capacity <code>n</code>, we only need to call <code>AllocTraits::allocate(a, n)</code>
      and convert the result into a true pointer, say <code>p</code>, of type <code>T *</code>, to the first
      available slot.</p>
    <p>Given this pointer to the start of the sequence, we can start constructing elements. Very crudely, we
      can default-construct <code>k</code> elements with no-throwing constructors like this:</p>
    <div class="code">for (T * x = p; x != p + k; ++x) { AllocTraits::construct(a, x); }</div>
    <p>If exceptions may occur, we also need to track our progress, catch exceptions, and in the
      event of an exception destroy the already constructed elements before rethrowing the caught
      exception.</p>
    <p>The contiguous array is an example where the allocator fits most naturally. There is no need to rebind
      or to construct elements of different types. The allocator neatly separates the allocation of memory
      from the construction of objects.</p>

    <h2 id="propagation">Propagating allocators</h2>

    <p>A single dynamic container with an allocator is a fine thing, but it is only the first step.
      Two separate sets of questions arise naturally.</p>

    <ol>
      <li>What happens when you copy the container? What kind of allocator does the copy get? What happens when you
        assign to a container or swap to containers? Are the allocators swapped, too, or is only the data swapped?</li>
      <li>If the container contains types which themselves require an allocator, how can the contained elements
        be made aware of the container&rsquo;s allocator so that they may use compatible allocators?</li>
    </ol>

    <p>The two problems are orthogonal to one another. Both require a fair amount of machinery.</p>

    <h3>Lateral allocator propagation: copy, assign, swap</h3>

    <p>If an allocator is stateless, then all container objects that use the same allocator type have compatible
      allocators, and there is no problem. For example, swapping two containers can be achieved by simply exchanging
      internal memory handles; either container&rsquo;s allocator knows how to deallocate the memory.</p>

    <p>However, when allocators are stateful, the situation is more complicated. We distinguish three situations which
      require a policy decision:</p>
    <ul>
      <li>Container copy. Suppose container <code>X</code> uses an allocator of type <code>Alloc</code>. Given <code>X x1</code>,
        which allocator does <code>X x2(x1)</code> use? It could either be a copy of <code>x.get_allocator()</code>, or it could
        be a default-constructed, new allocator, or it could be something else. The universal answer is provided by
        <code>AllocTraits::select_on_container_copy_construction(x1.get_allocator())</code>. This trait is configurable,
        e.g. via the member function <code>Alloc::select_on_container_copy</code>, and the default is to return a copy
        of the existing allocator.</li>
      <li>Assignment (copy and move assignment). When you say <code>x1 = x2</code>, or more interestingly yet, <code>x1
        = std::move(x2)</code>, you have to decide whether <code>x1</code> is supposed to take the allocator from <code>x2</code>
        or to keep its own allocator. Either choice has advantages and disadvantages in the case where the two allocators
        are not equal, and so neither one can deallocate the other one&rsquo;s memory. If the allocator is reassigned, then
        it may be necessary to deallocate the currently held data with the old allocator first, and allocate new memory
        with the newly assigned allocator, rather than keeping the exisitng memory and just reassigning the element values.
        On the other hand, if the allocator is reassigned, move-assignment is efficient, since the entire internal allocation
        can just be moved over to <code>x1</code>. If the allocator is not reassigned, move-assignment would require an actual
        element-by-element copy. The desired policy is chosen by means of the types <code>AllocTraits::propagate_on_container_copy_assignment</code>
        (&ldquo;POCCA&rdquo;) and <code>AllocTraits::propagate_on_container_move_assignment</code> (&ldquo;POCMA&rdquo;), which
        are either <code>std::true_type</code> or <code>std::false_type</code>. Note that this choice is made per allocator
        <em>type</em>, not per object.</li>
      <li>Swap. The same considerations apply in principle as for assignment, and the controlling trait is
        <code>AllocTraits::propagate_on_container_swap</code> (&ldquo;POCS&rdquo;). However, the standard library container
        requirements mandate that POCS is either true, or that otherwise the allocators of the containers that are to
        be swapped compare equal. If this were not required, then swapping with unequal, unswapped allocators could not
        preserve iterators.</li>
    </ul>

    <h3>Deep allocator propagation: the <code>uses_allocator</code> construction</h3>

    <p>Suppose we have a vector of linked lists, and the vector uses some allocator of our choice. Even if we
      used a list type that would also be configured to use an allocator of the same type as our vector&rsquo;s
      allocator, we still need a mechanism for ensuring that the vector elements (which themselves are lists)
      are constructed with the correct allocator (namely with a suitably rebound copy of the vector allocator).</p>

    <p>To tackle this problem, we need a standard convention how allocators are passed to class constructors.
      The standard library provides the following machinery.</p>
    <ol>
      <li>There is yet another trait class template, <code>std::uses_allocator&lt;X, A&gt;</code>, which
        contains a boolean member constant <code>std::uses_allocator&lt;X, A&gt;::value</code>. For brevity,
        let us write <code>UsesAlloc&lt;X&gt; = std::uses_allocator&lt;X, Alloc&gt;::value</code> for the value
        of this trait for our allocator class <code>Alloc</code>. Then <code>UsesAlloc&lt;X&gt;</code> is <code>true</code>
        if either the trait has been thus specialized, or otherwise if <code>X</code> defines a member type
        <code>X::allocator_type = Alloc</code>. In other words, <code>UsesAlloc&lt;X&gt;</code> tells us whether
        the class <code>X</code> uses the allocator <code>Alloc</code>.</li>
      <li>If <code>UsesAlloc&lt;X&gt;</code> is <code>true</code>, then we assume that either
        <ul>
          <li><code>X</code> has a constructor <code>X::X(std::allocator_arg_t, Alloc const &amp;, Args...)</code>,
            where the second parameter is the desired allocator, or</li>
          <li><code>X</code> has a constructor <code>X::X(Args..., Alloc const &amp;)</code>,
            where the final parameter is the desired allocator.</li>
        </ul>
        The second form is the &ldquo;legacy form&rdquo; employed by the traditional standard library containers;
        the first form is the recommended, new style, which is unambiguous. Classes whose constructors accept allocators
        in this fashion are sometimes called &ldquo;allocator-extended&rdquo;. (Not every class that has allocator-extended
        constructors actually consumes an allocator. An example is <code>std::tuple</code>, for which the
        <code>uses_allocator</code> trait is specialized to <code>true</code>, so that allocators may be propagated
        through tuples of types which themselves require an allocator.)</li>
      <li>Now it gets complicated. We will present only the simplest case, but the standard library provides far more
        advanced machinary. Suppose both our out vector and our inner linked list type should use an allocator of type
        <code>Alloc</code>, and they should use compatible allocators (i.e. their all their allocators should compare
        equal). Suppose further we already have an allocator <code>Alloc a</code>, and that both our vector and our
        list class take the new form of constructor. Then we use a new allocator:<br><br>
        <div class="code">ScopedAlloc = std::scoped_allocator_adaptor&lt;Alloc&gt;
        ScopedAllocTraits = std::allocator_traits&lt;ScopedAlloc&gt;</div>
        <br>We construct our vector like this:<br><br>
        <div class="code">using ListType = List&lt;T, ScopedAllocTraits::rebind_alloc&lt;T&gt;&gt;;
          using VecType = Vector&lt;ListType, ScopedAllocTraits::rebind_alloc&lt;ListType&gt;&gt;;

          VecType v(std::allocator_arg, a);</div>
        <br>When the vector calls <code>std::allocator_traits&lt;...&gt;::construct(get_allocator(), p, arg1, arg2, arg2)</code>,
        this calls <code>get_allocator().construct(p, arg1, arg2, arg2)</code> on the scoped allocator adaptor. The adaptor
        in turn recognizes that <code>*p</code> has the <code>uses_allocator</code> trait, and thus it forwards the
        call to <code>std::allocator_traits&lt;AllocTraits::rebind_alloc&lt;ListType&gt;&gt;::construct(outer_allocator(),
        std::allocator_arg, *this, arg1, arg2, arg3)</code>. In this fashion, the allocator is always rebound-copied into
        the constructors of the element values, as long as those have the <code>uses_allocator</code> trait set.
      </li>
    </ol>

    <h2 id="examples">Examples</h2>

    <p>A few complete end-to-end examples are available on separate pages:</p>

    <ul>
      <li>Using allocators: <a href="allocator_example_usage.html">A simple arena allocator</a></li>
      <li>Writing allocators: A thread-local pool allocator [to be written]</li>
      <li>Writing containers: [to be written]</li>
    </ul>


    <h2 id="conclusion">Conclusion</h2>
    <p>[<em>Note. I'm not sure if this belongs here or will stay, but I didn't want to lose it.</em>]</p>

    <p>The mechanism to obtain dynamic memory is platform-dependent and opaque. We can make the argument that
      <em>any</em> direct uses of <code>new</code> and <code>delete</code> expressions should be avoided, as
      should any invocations of the (de)allocation functions <code>::operator new</code> and <code>::operator
      delete</code>. Moreover, neither global nor per-class overloads for those functions should be defined.
      Instead, dynamic allocations should be private to the implementation of classes, and library authors
      should allow their classes to be parametrized with allocators. If a class or class template can be
      used by client classes that may require allocators themselves, the parent allocator should be propagated.
      As a litmus test, it should be possible to instantiate a class in shared memory using fancy offset pointers.</p>

  


<!-- To do:

     * "value of type X&" doesn't make sense; values are never references
     * (void*) should be static_cast<void*>
     * Does "constructs an object of type C at c" not require use of "args"?
     * Allocator-agnostic free relational operators? Requires SCARY iterators for containers, and a change of compare() for basic_string.
-->

  </body>
</html>
